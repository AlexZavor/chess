# Java Fundamentals

### Javadoc
auto documentation
Takes comments from code to make webpage

/**
    javadoc description for class.
    @return return
*/
public class MyClass{

    /**
        javadoc description for method
        up to first '.' is summary
    */
    public void myMethod(){

    }
}

### Primitives
byte        - 8
short       - 16
int         - 32
long        - 64
float       
double      
char        - 'a' 16 bit \u for unicode identitys
boollean    - not 1/0. different datatype

### Output
System.out.println(int + test + ", " + long1);
System.out.printf("%d, %d, %d, %d \n", int, test, long1);

### Conversion
int Integer.parseInt(String value)
returns exception for incorrectly formatted thing
Wrapper class for all the primitives. with parse methods

### Strings
Technically not primitives
Immutable
Concatenations always make a new string.
String.format()                     // like printf() function for formatting a string.
String s = "Hello"                  // pointing to the same "hello" for the same string.
String s = new String("Hello");     // Same literal. makes a copy. not really helpful
String concatenation is slow
    so use a StringBuilder instead
    builder = new StringBuilder();
    builder.append
    String str = builder.toString();

### Arrays

int [] intArray;            // is an object. not primitive, reference to an array
intArray = new int[10];     // actually makes the array. points the reference to it
intArray[0] = 500;          // initialize

int [] intArray2 = {1, 2, 3, 4}; // All at once
They actually know how big they are
intArray.length

for (int value : intArray2){
    System.out.print(value);
}

multidementional arrays
the arrays inside can be different sizes.

### Command Line Arguments
don't need length argument. just call .length on array
0th argument isn't name of program

### Package
Organizing packages into groups. 
java.util.Date
often put it inside domain name
edu.byu.cs
    public class Student{}

must use the full package name of the class every time unless...

### Imports
Similar to includes. but different.
you can use just the first short name in that file
does not increase the code size really. 
Java.lang.*
    Object, string, ext
    implicitly imported.
Anything in the same package is also implicity imported. (same folder)

### ClassPath
Like PATH for terminal
all the folders. kinda like a library folder.
Managed by IntelliJ.
ends up in the default package if not specified.

# Classes and Objects

### Class
Class is a template for an object. if and when you make it.
Basically everything goes in classes.
Strings and arrays are object that can be made without "new"
Objects go on heap
Static variables can go on stack. but thats about it.
Date dt;            //like a pointer or reference to what would be a date
dt = new Date();    //Creates an actual object. returns reference to it.

### References
allows acess to objects
cant just move it like in C (p+4)
references do not create objects.
multiple references can refer to the same object.
no references allow garbage collection.

p1 == p2        // just compares address (simmilar object fail)
p1.equals(p2)   // compares the actual contents of the object (**does the same thing if not overwritten**)

### Static Variables & methods
Most of the time Instance variables.
    each instance gets a new copy of the variables
    Instance methods run off of the data in the object it was excituted on.
but if we use Static
    one variable for the class.
    or one method that can be called without a copy of the object (like main)

### Getters and Setters
Instance variables should be private, make getters and setters (Accessor / Mutator)
protects your variables
can be autogenerated by IntelliJ

### Constructor
when you new Class()
It runs the constructor
must match class name (upper case 1st letter, Camel Case)
Methods (Lower case 1st, Camel Case)
no return type
All classes have at least one constructor (even if its just a default)
Can have different constructors with different arguments.
invoke other instructors - this()
Constructors invoke parents - super()
Those two will be the first line of code. in a constructor. always. (goes up to Object class)

# Records
A lot of classes just have data, and basically auto generated methods
so they made an easy library called Lombok
then Java was like... why don't we just do it ourseves?
class, getters, setters, .equals(), .hashcode ext.
or. 
public record Ped(int id, String name, String type) {}
    all feilds are final, no setters
    constructors take in all fields.
    kinda just simple data class.
    to rename, you have to make a new object.

# Programing Exam
Closes Thurs 5pm
4 hours
take a practice run
details on canvas

# Exceptions
Try catch
Exceptions are not necccisarily errors.
represented as classes and objects
better than manually error checking like in C
try{
    code that could go wrong
}
catch (type of exception) {
    how to handle if it goes wrong.
}   // could have multiple catches

should either handle or declare
    handle with a catch, 
    or pass it up to parent function. and someone else with handle it
    or it will crash.

Finally 
    runs always. no matter if there was an exception or not.
    useually for cleaning up with or without errors

Try with Resources
    try(open things that could error with "autocloseable" interface) {
        if it works run here
    }

Throw yourself
    throw new AHHHHHHHHException("debug text");

shouldn't catch (definelty not swallow) a runtime exception
    catch(RuntimeException ex){
        throw ex
    }

overwriteen methods exception
    can't throw new exceptions
    can throw fewer.
    can throw subclasses of the same ones

# Collections
Many classes that all apply to the same interface that we can use.

### List
Sequence of elements acessed by index. .get(index) .set(index, value)
    Array list
    Linked list
    ListIterator
        yay iterators, auto for loops, cool stuff
### Set
Collection with no duplicates, but no order either
    add() contains() remove()
    HashSet
    TreeSet (sortable)
    LinkedHashSet (linked list but quiet)
### Queue
Good for processing
    add(value) peek() remove()
    ArrayDeque (fifo, resizable array)
    LinkedList (fifo, linked list)
    PriorityQueue (binary heap)\
### Deque
queue that supports work from both ends
    addFirst, addLast, peekFirst, peekLast, removeFirst, removeLast
    ArrayDeque
    Stack? no, its mostly just slow sometimes because it is thread safe.
        just use an ArrayDeque
### Map
key value pairs
    use key, get data you want.
    put(key, value), get(key), contains(key), remove(key)
    keyset(), values(), entrySet()
    HashMap (hash table implementation)
    TreeMap
    LinkedHashMap
### Iterable
nice and iterable
    for(String : words){}

### Other
make sure you need a .equals() for what goes inside.
check for your .hashCode() if your collection uses hash
those two should be based on the same thing

don't change something that is used as a key
    or else you have to remove, change, reinsert

Some are sorted, things need to be sortable. 
    make comparable interface or comparitor
    compareTo(anotherOne one)

# Copy Objects
Sometimes you want a copy of an object.
Shallow copy and Deep copy
Shallow copy
    reference points to the same object.
Deep copy
    reference points to a new object with the same data

How to copy
    copy Constructors (more C)
    Clone method on each class (more Java)

public class Person implements Clonable {  //Clonable just marks it, no extra methods, but allows clone "clone not supported exception"
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone(); // Just returns a shallow copy
    }
    
    @Override
    public Object clone() throws CloneNotSupportedException {
        Person2 clone = (Person2) super.clone();


        Date clonedBirthdate = (Date) getBirthdate().clone();
        clone.setBirthdate(clonedBirthdate)


        return clone;
    }
}

# Inner Classes

### Why would we want this?
class{
    variables
    methods
    methods
    inner class{
        variables
        methods
    }
    private innerClass();
}
perhaps for an *iterator*? implement it differently for the same idea on different objects
### Kinds
nested classes
    mostly for keeping organized. hiding in the class
    can be static, can be private. 
        Static makes it separate from the class
        without it can access see the members of the outer class instance.

    keep things close to where they are used

    What if its all really big?
    What if you make the class.. right inside the method!
    can just use the local variable, 
        BUT, you have to treat the variable as final, or effectively final
Ananomous
    just is literally in the part where you make it
    make a new object that works this way, doesn't matter what it is, won't use it again.
    new Iterator() {        \\ Implementing an interface of iterator
        required methods
        required methods
    };

# Design Principles
What do we want?
Create systems that:
    work
    easy to understand
    strong
    reuseable

Design is inherintally Iterative
    design implement test repeat
    designing all up front does not work!
    begin with some design, make some
    Data structure is important (vector or array?)

Information Hiding
    make how things work hidden
    make what they do public
    name things that hide the implementation
    but work with interfaces

Code Duplication
    dont do it! or else fixing things causes fixing thing repeatedly (and missing things)
    have one and called
    inheritance

### Abstraction
dealing with complexity
provide abstractions that model the *machine*
    put data for a chess piece in a chess piece class

sometimes represent real things
    others aren't
    http:, Database, Hashtable

each abstraction are done with classes in Java
Design public interface so people can interact how they like.

Often can't represent all aspects of it.
    represent what is relevant
    based on how youll use it.

### Good Names
Naming things matters!
if it has a bad name, then you have to dig through the code
    Class - noun  (Cat)
    Method - Verb (doThisThing)

every abstraction shoud have one reason to live
    are they easy to name? no? then it's doing too much.

### Decomposition
Helps tame complexity
Make big problems into multiple small problems

# Input/Output
### Streams
    read or write a file sequentially
    Just read a stream of bytes, one byte at a time (file, input, database, piped(thread))
    Input/OutputStream
        reading and writing bytes
    Reader / Writer
        reading and writing chars
        from Streams to Reader/Writer
            InputStreamReader(takes stream)
            OutputStreamWriter(takes stream)

    **Filter Streams**
        connect stream to stream
            read bytes -> decrypt -> counting -> buffering
### Scanner
    attatch to file or stream. tokenized input (line, word, command)
    default is white space
    add in different tokens with a regular expression
### File
    Just read in the whole thing at once
    represents a file. 
        File file = new File("/directory/to/File");
        if(file.exists());
        file.createNewFile();
        file.delete();
### RandomAccessFile
    use a file pointer to read wherever
    .seek(long) (go to that point)
    .skipBytes(int) (this + int)

# JSON
The more modern and prefered data format for between computers (xml old)

### Structure
Suported Data type:
    Objects {"name":"John", "type":"person"}
    Arrays, ["testing", 2, 8]
    Numbers, Strings, Bool, Null

### Parser
Most languages already have built in parsers
    Serializers / Deserializer
        Straight from JSON to Java objects (Gson)
    Stream Parser
        Tokenize things, passed to you one at a time. (have to rebuild yourself)
    DOM
        represents the data as a tree to navigate

    must match class structure
    Serialization -> Json


    Gson gson = new GsonBuilder().setPrettyPrinting().create();
    String jsonString = Gson.toJson(*object to Jsonfy*)

    BufferedReader bufferedReader = new BufferedReader(file)
    Gson gson = new Gson();
    Obj. name = gson.fromJson(bufferedReader, Obj.class)


# Phase 2
Goal. design phase 3
make diagrams to show the design of phase 3
Server - A program waiting for information from another computer (http)

userData class
authToken class
gameData class

DAO for each.

Main server, 
many handlers,
request/result
many serveces

package (folder) with serveces
sub package for requests
sub package for results

handelers not pictured in example (just json dealings)

# HTTP
Request and receve data from ohter computers
who are we contacting? IP address
DNS servers hold names for numbers (like a big contact book)

Then you connect to a machine, but what do we want to do on that machine?
port (like extention)

https://www.google.com:443/images/blah blah blah
(lang)  (Domain)     (port)    (path)

Responce
200: succsess
300: information
400: error. do better
500: I messed up. oops
pass headers, then data

headers request authorization

GET
get some data
headers 
\n
body return


POST
create some data
headers
\n
request body

responce may have data

types (REST api):
GET
    nothing really in request
POST
    body included
PUT
    body included
DELETE
    no body included
other
    HEAD, OPTIONS, TRACE, PATCH

# Phase 3
### SparkJava, uses Lambdas
sending Http between data and server

import spark.Spark;

public class
    public main()
        Spark.get("/hello", (req,res) -> "Hello BYU!");

Default port is 4567
localhost:4567/hello

Spark.prot(port);

get
post
put
delete

lambda function should do more.
request.
    .body()     //get request body
    .headers()  //recive all headers as set of strings
    .header("...")  //get specific header
response.
    .body()     //Sets body
    .status()   //sets status

### Serving Static files
    Spark.staticFiles.location("/directory")

create a folder in server, mark as "resources directory"

### Filters
before("/pathfilter/*", (request, response) -> {
    //check autheticated
    ext.
    runs before each route
})

### Install
make a Maven project (package manager)
make a Gradle project
or just add it yourself.
    file, project structure
    modules, dependencies, +, library, from Maven
    sparkjava

### Design
Server
    holds all the hooks and runs spark
Handlers
    takes each of the hooks
    deals with gson to and from
    request/response objects needed
Secedes
    takes in requests, returns responses
    holds the logic of what to do.
Request/response
    lots of simple classes (record?)
    used for data passing
Data Access
    called from services, done with **interfaces**
    will be changed later, for now just have static data
    list
    keep from forgetting?
        static (eh. its temp anyway)
        not new instances (change a lot)
        another external class with the actual data.
models
    objects that represent our data bits
    also maybe records

# Curl
kinda easy, command line server access
raw returns from http
-X POST (GET is default)
-v Verbose
-d body data '{"name":"joe"}'
-H header data
-o output response to file
--data-binary @filename

interesting for debugging

# Write Quality code
videos
names are important
methods should do one thing and should be clear with names
returns void? action, verb phrase
    worry about bad verbs (handle, perform, deal)
### Methods
Why write more?
avoid code duplication, avoid deep nesting, decomposition

# Testing
Writing tests is important, because assuming it all works is a bad idea

System
    run the entire thing
Intermediate test
    joining different units
Unit tests
    just small ones testing single things

Automated tests are easy. so they get done. 
    if you add a new feature, do you want to run all the tests again?
    or would you rather click a button and add a little test code.

Regression
    if you fix something, but causes new errors, regression happens
    tests do that

Test driver
    needs to know how to identify, run and tell if something went wrong.
    needs to be easy.

### Junit Testing Framework
Pretty famous, works on a lot of languages (started in java)
CppUnit, PyUnit, ext.
write a method in a class that runs the test
    @Test tells it it is a test
    @BeforeEach tells it to run the method before each
    @AfterAll ext. ext.
    Assertions.assert methods to tell if something is right

### Code coverage
There is a test that looks at how many things are actually tested
    line coverage - what lines are covered
    Statement coverage - about the same
    Branch coverage - checks between each branch of if/else ext.
    Function coverage - checks each function.

There is no "right" level of code coverage.
Some companies have different levels.
there are tools to check

# Relational Databases
made of tables, that has collumns of each variable
    including a primary key that is unique to each member
Forien key- a primary key in another table that can relate members across tables.

### Key types
Key needs-
    unique for every row.
    every row has one.
Primary-artifical
    something just assigned without real meaning (1-'dracula')
Primary-natural
    also has real meaning, as long as it works as a key
Composite 
    multiple collumns that work together to be a key

### Relationships
one to one
    person - SSN
    mash them gothether?
    or one table gets the primary key of the other
One to many
    Catagorys
    take key from many and put in one table
Many to many
    who has done what?
    create another table to put keys of both

### Making a Relationship Diagram
lines to show related, crows foot is many, dash is one
circile means that it is optional.

### Classes mapped to relationship diagrams
make needed classes?
make all classes?
unification?
depends on usage.

# SQL
Language for database operations
data types:
    CHAR(n)        fixed width character string
    VARCHAR(n)     variable width string with max size n
    BIT(n)         array of n bits
    BIT VARYING(n) 
    INTEGER and SMALLINT
    FLOAT, REAL and DOUBLE PRECISION
    NUMERIC(precision, scale) or DECIMAL(precision, scale)
    BLOB            binary large object (image, sound, bin, ext)
    CLOB            character large object (text doc)
    DATE
    TIME
    TIME WITH TIME ZONE
    TIMESTAMP
    TIMESTAMP WITH TIME ZONE
Create Tables
    doing work rather than logic
    create table book (
        id integer not null primary key auto_increment,
        title varchar(255) not null,
        author varchar(255) not null,
        genre varchar(32) not null,
        category_id integer not null,
        foreign key(genre) references genre(genre),
        foreign key(category_id) references category(id)
    );
Drop Tables
    drop table book;              // just goes for it, might have error
    drop table if exists book;    // might be smarter, put at top for debugging to make sure you have an empty workspace

Insert rows
    insert into book 
    (title, author, genre, category_id) values ('The work and the Glory', 'Gerald Lund', 'HistoricalFiction', 3);
Update rows
    if no WHERE clause, then it will effect all rows
    UPDATE member
    SET name = 'Chris Jones',
        email_address = 'chris@gmail.com'
    WHERE id = 3
Delete rows
    DELETE FROM member
    WHERE id = 3

### JDBC
SELECT column, column (* works)
FROM table
WHERE column = ""

table.column
no where clause? all of the above (for multiple tables makes cartesian projects)
AND for where clause
member.id = books_read.member_id AND book.id = books_read.book_id AND genre = "NonFiction"

INNER JOIN (between FROM and WHERE) books_read ON member.id = books_read.member_id
INNER JOIN book on books_read.book_id = book.id

**Transactions**
All or nothing is best.
BEGIN TRANSACTION
SQL statement 1;
SQL statement 2;
...
COMMIT TRANSACTION; or ROLLBACK TRANSACTION;

**In java**
Java.SQL.*

Load database driver
    //not necessary anymore really
    try{
        Class.forName("org.sqlite.JDBC");
    } catch (ClassNotFoundException e){ //error nonsense }
open a database connection
    make connectionURL string
    Connection connection = null;
    try catch{
        Connection c = DriverManager.getConnection(URL)
        either with resources, or make sure finally has close
    }
start a transaction
    // for this class we can just leave auto commit on.
    connection.setAutoCommit(false);
execute queries and/or updates
    Look on slides
commit or rollback the transaction
    connection.commit();
    connection.rollback();
close database connection
    
retrieving auto-increment ids
    set flag in statement, then ask for it.

Getting JDBC
add to pom.xml to add it in.

# Phase 5: Pregame
Terminal, spec, API
Drawing text to screen to draw each token. a lot like it. 
two UIs, pre logged in, post logged in
thursday connecting to API.

API Calls
    connect to server. talk through bytes
Code examples on slides. very good.

# Logging
Built in loggers, make a logger, set a priority level.

# Defensive Programming
Write fewer bugs
    - Assertions
        write in assertions for your assumptions ( this value should be in this range ext.)
        run with configuration java -ea or won't be compiled
    - Parameter Checking
        Could do with assertions
        throw invalid argument exception
        Decide? do you have control over calling code? assertions
        don't? probably exceptions.

# Web Socket
### HTTP review
Client initiates, server responds
great for getting information
    not great for communication across server
reply only
    perhaps with pings, or short polling
        expensive
    long polling
        just wait until there is a reply, server only replies when they have data
    Polling in general
        just kinda slow, expensive, and application specific
Web Socket
    uses HTTP
    bidirectional!
    request and then it runs HTTP++

Spark.webSocket("/connect", WebSocket.class);

Examples in pet shop

# Phase 6
you want to make notifications, update board, joins and observers

Server gets a session, relate to username, check game for what usernames, notify sessions.

