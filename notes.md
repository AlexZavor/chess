# Java Fundamentals

### Javadoc
auto documentation
Takes comments from code to make webpage

/**
    javadoc description for class.
    @return return
*/
public class MyClass{

    /**
        javadoc description for method
        up to first '.' is summary
    */
    public void myMethod(){

    }
}

### Primitives
byte        - 8
short       - 16
int         - 32
long        - 64
float       
double      
char        - 'a' 16 bit \u for unicode identitys
boollean    - not 1/0. different datatype

### Output
System.out.println(int + test + ", " + long1);
System.out.printf("%d, %d, %d, %d \n", int, test, long1);

### Conversion
int Integer.parseInt(String value)
returns exception for incorrectly formated thing
Wrapper class for all of the primitives. with parse methods

### Strings
Technically not primitives
Immutable
Concatinations always make a new string.
String.format()                     // like printf() function for formating a string.
String s = "Hello"                  // pointing to the same "hello" for the same string.
String s = new String("Hello");     // Same literal. makes a copy. not really helpful
String concatenation is slow
    so use a StringBuilder instead
    builder = new StringBuilder();
    builder.append
    String str = builder.toString();

### Arrays

int [] intArray;            // is an object. not primitive, reference to an array
intArray = new int[10];     // actually makes the array. points the reference to it
intArray[0] = 500;          // initialize

int [] intArray2 = {1, 2, 3, 4}; // All at once
They actually know how big they are
intArray.length

for (int value : intArray2){
    System.out.print(value);
}

multidementional arrays
the arrays inside can be different sizes.

### Command Line Arguments
don't need length argument. just call .length on array
0th argument isn't name of program

### Package
Organizing packages into groups. 
java.util.Date
often put it inside domain name
edu.byu.cs
    public class Student{}

must use the full package name of the class every time unless...

### Imports
Similar to includes. but different.
you can use just the first short name in that file
does not increase the code size really. 
Java.lang.*
    Object, string, ext
    implicitly imported.
Anything in the same package is also implicity imported. (same folder)

### ClassPath
Like PATH for terminal
all the folders. kinda like a library folder.
Managed by IntelliJ.
ends up in the default package if not specified.

# Classes and Objects

### Class
Class is a template for an object. if and when you make it.
Basically everything goes in classes.
Strings and arrays are object that can be made without "new"
Objects go on heap
Static variables can go on stack. but thats about it.
Date dt;            //like a pointer or reference to what would be a date
dt = new Date();    //Creates an actual object. returns reference to it.

### References
allows acess to objects
cant just move it like in C (p+4)
references do not create objects.
multiple references can refer to the same object.
no references allow garbage collection.

p1 == p2        // just compares address (simmilar object fail)
p1.equals(p2)   // compares the actual contents of the object (**does the same thing if not overwritten**)

### Static Variables & methods
Most of the time Instance variables.
    each instance gets a new copy of the variables
    Instance methods run off of the data in the object it was excituted on.
but if we use Static
    one variable for the class.
    or one method that can be called without a copy of the object (like main)

### Getters and Setters
Instance variables should be private, make getters and setters (Accessor / Mutator)
protects your variables
can be autogenerated by IntelliJ

### Constructor
when you new Class()
It runs the constructor
must match class name (upper case 1st letter, Camel Case)
Methods (Lower case 1st, Camel Case)
no return type
All classes have at least one constructor (even if its just a default)
Can have different constructors with different arguments.
invoke other instructors - this()
Constructors invoke parents - super()
Those two will be the first line of code. in a constructor. always. (goes up to Object class)

# Records
A lot of classes just have data, and basically auto generated methods
so they made an easy library called Lombok
then Java was like... why don't we just do it ourseves?
class, getters, setters, .equals(), .hashcode ext.
or. 
public record Ped(int id, String name, String type) {}
    all feilds are final, no setters
    constructors take in all fields.
    kinda just simple data class.
    to rename, you have to make a new object.

# Programing Exam
Closes Thurs 5pm
4 hours
take a practice run
details on canvas

# Exceptions
Try catch
Exceptions are not necccisarily errors.
represented as classes and objects
better than manually error checking like in C
try{
    code that could go wrong
}
catch (type of exception) {
    how to handle if it goes wrong.
}   // could have multiple catches

should either handle or declare
    handle with a catch, 
    or pass it up to parent function. and someone else with handle it
    or it will crash.

Finally 
    runs always. no matter if there was an exception or not.
    useually for cleaning up with or without errors

Try with Resources
    try(open things that could error with "autocloseable" interface) {
        if it works run here
    }

Throw yourself
    throw new AHHHHHHHHException("debug text");

shouldn't catch (definelty not swallow) a runtime exception
    catch(RuntimeException ex){
        throw ex
    }

overwriteen methods exception
    can't throw new exceptions
    can throw fewer.
    can throw subclasses of the same ones

# Collections
Many classes that all apply to the same interface that we can use.

### List
Sequence of elements acessed by index. .get(index) .set(index, value)
    Array list
    Linked list
    ListIterator
        yay iterators, auto for loops, cool stuff
### Set
Collection with no duplicates, but no order either
    add() contains() remove()
    HashSet
    TreeSet (sortable)
    LinkedHashSet (linked list but quiet)
### Queue
Good for processing
    add(value) peek() remove()
    ArrayDeque (fifo, resizable array)
    LinkedList (fifo, linked list)
    PriorityQueue (binary heap)\
### Deque
queue that supports work from both ends
    addFirst, addLast, peekFirst, peekLast, removeFirst, removeLast
    ArrayDeque
    Stack? no, its mostly just slow sometimes because it is thread safe.
        just use an ArrayDeque
### Map
key value pairs
    use key, get data you want.
    put(key, value), get(key), contains(key), remove(key)
    keyset(), values(), entrySet()
    HashMap (hash table implementation)
    TreeMap
    LinkedHashMap
### Iterable
nice and iterable
    for(String : words){}

### Other
make sure you need a .equals() for what goes inside.
check for your .hashCode() if your collection uses hash
those two should be based on the same thing

don't change something that is used as a key
    or else you have to remove, change, reinsert

Some are sorted, things need to be sortable. 
    make comparable interface or comparitor
    compareTo(anotherOne one)

# Copy Objects
Sometimes you want a copy of an object.
Shallow copy and Deep copy
Shallow copy
    reference points to the same object.
Deep copy
    reference points to a new object with the same data

How to copy
    copy Constructors (more C)
    Clone method on each class (more Java)

public class Person implements Clonable {  //Clonable just marks it, no extra methods, but allows clone "clone not supported exception"
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone(); // Just returns a shallow copy
    }
    
    @Override
    public Object clone() throws CloneNotSupportedException {
        Person2 clone = (Person2) super.clone();


        Date clonedBirthdate = (Date) getBirthdate().clone();
        clone.setBirthdate(clonedBirthdate)


        return clone;
    }
}

# Inner Classes

### Why would we want this?
class{
    variables
    methods
    methods
    inner class{
        variables
        methods
    }
    private innerClass();
}
perhaps for an *iterator*? implement it differently for the same idea on different objects
### Kinds
nested classes
    mostly for keeping organized. hiding in the class
    can be static, can be private. 
        Static makes it separate from the class
        without it can access see the members of the outer class instance.

    keep things close to where they are used

    What if its all really big?
    What if you make the class.. right inside the method!
    can just use the local variable, 
        BUT, you have to treat the variable as final, or effectively final
Ananomous
    just is literally in the part where you make it
    make a new object that works this way, doesn't matter what it is, won't use it again.
    new Iterator() {        \\ Implementing an interface of iterator
        required methods
        required methods
    };

# Design Principles
What do we want?
Create systems that:
    work
    easy to understand
    strong
    reuseable

Design is inherintally Iterative
    design implement test repeat
    designing all up front does not work!
    begin with some design, make some
    Data structure is important (vector or array?)

Information Hiding
    make how things work hidden
    make what they do public
    name things that hide the implementation
    but work with interfaces

Code Duplication
    dont do it! or else fixing things causes fixing thing repeatedly (and missing things)
    have one and called
    inheritance

### Abstraction
dealing with complexity
provide abstractions that model the *machine*
    put data for a chess piece in a chess piece class

sometimes represent real things
    others aren't
    http:, Database, Hashtable

each abstraction are done with classes in Java
Design public interface so people can interact how they like.

Often can't represent all aspects of it.
    represent what is relevant
    based on how youll use it.

### Good Names
Naming things matters!
if it has a bad name, then you have to dig through the code
    Class - noun  (Cat)
    Method - Verb (doThisThing)

every abstraction shoud have one reason to live
    are they easy to name? no? then it's doing too much.

### Decomposition
Helps tame complexity
Make big problems into multiple small problems

# Input/Output
### Streams
    read or write a file sequentially
    Just read a stream of bytes, one byte at a time (file, input, database, piped(thread))
    Input/OutputStream
        reading and writing bytes
    Reader / Writer
        reading and writing chars
        from Streams to Reader/Writer
            InputStreamReader(takes stream)
            OutputStreamWriter(takes stream)

    **Filter Streams**
        connect stream to stream
            read bytes -> decrypt -> counting -> buffering
### Scanner
    attatch to file or stream. tokenized input (line, word, command)
    default is white space
    add in different tokens with a regular expression
### File
    Just read in the whole thing at once
    represents a file. 
        File file = new File("/directory/to/File");
        if(file.exists());
        file.createNewFile();
        file.delete();
### RandomAccessFile
    use a file pointer to read wherever
    .seek(long) (go to that point)
    .skipBytes(int) (this + int)