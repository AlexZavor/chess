# Java Fundamentals

### Javadoc
auto documentation
Takes comments from code to make webpage

/**
    javadoc description for class.
    @return return
*/
public class MyClass{

    /**
        javadoc description for method
        up to first '.' is summary
    */
    public void myMethod(){

    }
}

### Primitives
byte        - 8
short       - 16
int         - 32
long        - 64
float       
double      
char        - 'a' 16 bit \u for unicode identitys
boollean    - not 1/0. different datatype

### Output
System.out.println(int + test + ", " + long1);
System.out.printf("%d, %d, %d, %d \n", int, test, long1);

### Conversion
int Integer.parseInt(String value)
returns exception for incorrectly formated thing
Wrapper class for all of the primitives. with parse methods

### Strings
Technically not primitives
Immutable
Concatinations always make a new string.
String.format()                     // like printf() function for formating a string.
String s = "Hello"                  // pointing to the same "hello" for the same string.
String s = new String("Hello");     // Same literal. makes a copy. not really helpful
String concatenation is slow
    so use a StringBuilder instead
    builder = new StringBuilder();
    builder.append
    String str = builder.toString();

### Arrays

int [] intArray;            // is an object. not primitive, reference to an array
intArray = new int[10];     // actually makes the array. points the reference to it
intArray[0] = 500;          // initialize

int [] intArray2 = {1, 2, 3, 4}; // All at once
They actually know how big they are
intArray.length

for (int value : intArray2){
    System.out.print(value);
}

multidementional arrays
the arrays inside can be different sizes.

### Command Line Arguments
don't need length argument. just call .length on array
0th argument isn't name of program

### Package
Organizing packages into groups. 
java.util.Date
often put it inside domain name
edu.byu.cs
    public class Student{}

must use the full package name of the class every time unless...

### Imports
Similar to includes. but different.
you can use just the first short name in that file
does not increase the code size really. 
Java.lang.*
    Object, string, ext
    implicitly imported.
Anything in the same package is also implicity imported. (same folder)

### ClassPath
Like PATH for terminal
all the folders. kinda like a library folder.
Managed by IntelliJ.
ends up in the default package if not specified.

# Classes and Objects

### Class
Class is a template for an object. if and when you make it.
Basically everything goes in classes.
Strings and arrays are object that can be made without "new"
Objects go on heap
Static variables can go on stack. but thats about it.
Date dt;            //like a pointer or reference to what would be a date
dt = new Date();    //Creates an actual object. returns reference to it.

### References
allows acess to objects
cant just move it like in C (p+4)
references do not create objects.
multiple references can refer to the same object.
no references allow garbage collection.

p1 == p2        // just compares address (simmilar object fail)
p1.equals(p2)   // compares the actual contents of the object (**does the same thing if not overwritten**)

### Static Variables & methods
Most of the time Instance variables.
    each instance gets a new copy of the variables
    Instance methods run off of the data in the object it was excituted on.
but if we use Static
    one variable for the class.
    or one method that can be called without a copy of the object (like main)

### Getters and Setters
Instance variables should be private, make getters and setters (Accessor / Mutator)
protects your variables
can be autogenerated by IntelliJ

### Constructor
when you new Class()
It runs the constructor
must match class name (upper case 1st letter, Camel Case)
Methods (Lower case 1st, Camel Case)
no return type
All classes have at least one constructor (even if its just a default)
Can have different constructors with different arguments.
invoke other instructors - this()
Constructors invoke parents - super()
Those two will be the first line of code. in a constructor. always. (goes up to Object class)

# Records
A lot of classes just have data, and basically auto generated methods
so they made an easy library called Lombok
then Java was like... why don't we just do it ourseves?
class, getters, setters, .equals(), .hashcode ext.
or. 
public record Ped(int id, String name, String type) {}
    all feilds are final, no setters
    constructors take in all fields.
    kinda just simple data class.
    to rename, you have to make a new object.

# Programing Exam
Closes Thurs 5pm
4 hours
take a practice run
details on canvas

# Exceptions
Try catch
Exceptions are not necccisarily errors.
represented as classes and objects
better than manually error checking like in C
try{
    code that could go wrong
}
catch (type of exception) {
    how to handle if it goes wrong.
}   // could have multiple catches

should either handle or declare
    handle with a catch, 
    or pass it up to parent function. and someone else with handle it
    or it will crash.

Finally 
    runs always. no matter if there was an exception or not.
    useually for cleaning up with or without errors

Try with Resources
    try(open things that could error with "autocloseable" interface) {
        if it works run here
    }

Throw yourself
    throw new AHHHHHHHHException("debug text");

shouldn't catch (definelty not swallow) a runtime exception
    catch(RuntimeException ex){
        throw ex
    }

overwriteen methods exception
    can't throw new exceptions
    can throw fewer.
    can throw subclasses of the same ones

# Collections
Many classes that all apply to the same interface that we can use.

### List
Sequence of elements acessed by index. .get(index) .set(index, value)
    Array list
    Linked list
    ListIterator
        yay iterators, auto for loops, cool stuff
### Set
Collection with no duplicates, but no order either
    add() contains() remove()
    HashSet
    TreeSet (sortable)
    LinkedHashSet (linked list but quiet)
### Queue
Good for processing
    add(value) peek() remove()
    ArrayDeque (fifo, resizable array)
    LinkedList (fifo, linked list)
    PriorityQueue (binary heap)\
### Deque
queue that supports work from both ends
    addFirst, addLast, peekFirst, peekLast, removeFirst, removeLast
    ArrayDeque
    Stack? no, its mostly just slow sometimes because it is thread safe.
        just use an ArrayDeque
### Map
key value pairs
    use key, get data you want.
    put(key, value), get(key), contains(key), remove(key)
    keyset(), values(), entrySet()
    HashMap (hash table implementation)
    TreeMap
    LinkedHashMap
### Iterable
nice and iterable
    for(String : words){}

### Other
make sure you need a .equals() for what goes inside.
check for your .hashCode() if your collection uses hash
those two should be based on the same thing

don't change something that is used as a key
    or else you have to remove, change, reinsert

Some are sorted, things need to be sortable. 
    make comparable interface or comparitor
    compareTo(anotherOne one)

# Copy Objects
Sometimes you want a copy of an object.
Shallow copy and Deep copy
Shallow copy
    reference points to the same object.
Deep copy
    reference points to a new object with the same data

How to copy
    copy Constructors (more C)
    Clone method on each class (more Java)

public class Person implements Clonable {  //Clonable just marks it, no extra methods, but allows clone "clone not supported exception"
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone(); // Just returns a shallow copy
    }
    
    @Override
    public Object clone() throws CloneNotSupportedException {
        Person2 clone = (Person2) super.clone();


        Date clonedBirthdate = (Date) getBirthdate().clone();
        clone.setBirthdate(clonedBirthdate)


        return clone;
    }
}